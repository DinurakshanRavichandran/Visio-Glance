# -*- coding: utf-8 -*-
"""Fundus_image.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-e5JNhHe7QsM8lST_GJorklz6IcXSPHe
"""

from flask import Flask, request, jsonify, send_file
import numpy as np
import joblib
import tensorflow as tf
import matplotlib.pyplot as plt
import cv2
import os
from lime import lime_image
from skimage.segmentation import mark_boundaries
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from tensorflow.keras.applications.resnet50 import preprocess_input, ResNet50

app = Flask(__name__)

# Load model and ResNet50 feature extractor
model_path = 'Sakuna_Eye_Disease_Detection_Model.h5'
model = joblib.load(model_path)
resnet_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

class_names = ['Diabetic retinopathy', 'Normal', 'Glaucoma', 'Cataract']

# Function 1: Predict Disease
def predict_disease(image_path):
    img = load_img(image_path, target_size=(224, 224))
    img_array = img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = preprocess_input(img_array)
    features = resnet_model.predict(img_array, verbose=0)
    features = features.flatten()
    prediction = model.predict(features.reshape(1, -1))
    predicted_class_index = int(prediction[0])
    return class_names[predicted_class_index]

# Function 2: LIME Explanation
def show_lime_explanation(image_path):
    img = load_img(image_path, target_size=(224, 224))
    img_array = img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = preprocess_input(img_array)

    def predict_fn_lime(images):
        features = resnet_model.predict(images, verbose=0)
        features = features.reshape(features.shape[0], -1)
        predictions = model.predict(features)
        return predictions

    explainer = lime_image.LimeImageExplainer()
    explanation = explainer.explain_instance(img_array[0].astype('double'), predict_fn_lime, top_labels=1, hide_color=0, num_samples=1000)
    temp, mask = explanation.get_image_and_mask(explanation.top_labels[0], positive_only=True, num_features=5, hide_rest=False)

    plt.imshow(mark_boundaries(temp, mask))
    lime_path = 'lime_explanation.png'
    plt.axis('off')
    plt.savefig(lime_path, bbox_inches='tight')
    return lime_path

# Function 3: Grad-CAM Explanation
def show_grad_cam_explanation(image_path):
    img = load_img(image_path, target_size=(224, 224))
    img_array = img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array = preprocess_input(img_array)

    last_conv_layer = resnet_model.get_layer('conv5_block3_out')
    heatmap_model = tf.keras.Model([resnet_model.inputs], [last_conv_layer.output, resnet_model.output])
    with tf.GradientTape() as tape:
        conv_outputs, predictions = heatmap_model(img_array)
        loss = predictions[:, np.argmax(predictions[0])]
    grads = tape.gradient(loss, conv_outputs)[0]
    pooled_grads = np.mean(grads, axis=(0, 1, 2))
    heatmap = np.mean(conv_outputs[0], axis=-1)
    heatmap = np.maximum(heatmap, 0)
    heatmap /= np.max(heatmap)

    img = cv2.imread(image_path)
    heatmap = cv2.resize(heatmap, (img.shape[1], img.shape[0]))
    heatmap = np.uint8(255 * heatmap)
    heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
    superimposed_img = cv2.addWeighted(img, 0.6, heatmap, 0.4, 0)
    grad_cam_path = 'grad_cam.png'
    cv2.imwrite(grad_cam_path, superimposed_img)
    return grad_cam_path

@app.route('/predict', methods=['POST'])
def predict():
    file = request.files['file']
    file_path = 'uploaded_image.png'
    file.save(file_path)
    disease = predict_disease(file_path)
    return jsonify({'predicted_disease': disease})

@app.route('/lime', methods=['POST'])
def lime():
    file = request.files['file']
    file_path = 'uploaded_image.png'
    file.save(file_path)
    lime_path = show_lime_explanation(file_path)
    return send_file(lime_path, mimetype='image/png')

@app.route('/gradcam', methods=['POST'])
def gradcam():
    file = request.files['file']
    file_path = 'uploaded_image.png'
    file.save(file_path)
    grad_cam_path = show_grad_cam_explanation(file_path)
    return send_file(grad_cam_path, mimetype='image/png')

if __name__ == '_main_':
    app.run(debug=True)